import java.util.Random;
import java.util.Stack;

/**
 * @author Hayden Daly. I pledge my honor I have abided by the Stevens Honor System.
 * @version 1.0.0
 * Treap class that implements a comparable
 */
public class Treap<E extends Comparable> {

	/**
	 * Class to build the Nodes
	 * @param <E> generic type to be specified upon creation
	 */
	private class Node<E> {

		// Data fields
		public E data; // key for the search
		public int priority; // random heap priority
		public Node<E> left;
		public Node<E> right;

		// Constructors
		/**
		 * Constructor for Node of data of generic type E and priority of type int
		 * @param data data of type E for the Node to be constructed with
		 * @param priority ranks the priority of the Node for placement within the heap
		 */
		public Node(E data, int priority) {
			this.data = data;
			this.priority = priority;
			left = null;
			right = null;
			if (this.data == null) {
				throw new NullPointerException("Data field value is null");
			}
		}

		// Methods
		/**
		 * Performs a left rotation. Update the data and priority attributes as well as the left and right pointers of the involved nodes accordingly.
		 * @return Node<E> Same as above.
		 */
		Node<E> rotateLeft() {
			if (right != null) {
				Node<E> result = right;
				right = right.left;
				result.left = this;
				return result;
			}
			else {
				return this;
			}
		}
		/**
		 * Same as above but does with respect to the right
		 * @return Node<E> a reference to the root of the result.
		 */
		Node<E> rotateRight() {
			if (left != null) {
				Node<E> result = left;
				left = left.right;
				result.right = this;
				return result;
			}
			else {
				return this;
			}
		}
		/**
		 * Translates the node to a string
		 * @return String returns a string value
		 */
		public String toString() {
			String result = "(key=" + data + ", priority=" + priority + ")";
			return result;
		}
	}

	// Data fields
	private Random priorityGenerator;
	private Node<E> root;

	// Constructors
	/**
	 * Constructs empty Treap
	 */
	public Treap() {
		this.root = null;
		this.priorityGenerator = new Random();
	}

	/**
	 * Constructs empty treap with a seed
	 * @param seed
	 */
	public Treap(long seed) {
		this.root = null;
		this.priorityGenerator = new Random(seed);
	}

	// Methods
	/**
	 * Insert the given element into the tree, creating a new node containing key as its data and a random priority generated by priorityGenerator.
	 * @param key
	 * @return boolean True or False
	 */
	public boolean add(E key) {
		return add(key, priorityGenerator.nextInt());
	}

	/**
	 * Helper function for add
	 * @param key
	 * @param priority
	 * @return boolean true or false to end recursion
	 */
	public boolean add(E key, int priority) {
		Node<E> node = new Node<E>(key, priority);
        if (this.root == null) {
            this.root = node;
            return true;
        }
        Node<E> tempNode = this.root;
        Node<E> tempParent = null;
        Stack<Node<E>> tempStack = new Stack<Node<E>>();
        while (tempNode != null) {
            tempParent = tempNode;
            if (key.compareTo(tempNode.data) < 0) {
                tempStack.push(tempParent);
            	tempNode = tempNode.left;
            }
            else if (key.compareTo(tempNode.data) > 0) {
            	tempStack.push(tempParent);
            	tempNode = tempNode.right;
            }
            else {
            	return false;
            }
        }
        if (key.compareTo(tempParent.data) < 0) {
        	tempParent.left  = node;
        }
        else {
        	tempParent.right = node;
        }
        reheap(node, tempStack);
        return true;
    }

	/**
	 * Recursive helper function to be used in add and delete
	 * @param tempStack temporary stack to be cycled through recursive calls
	 * @param node current node for recursion
	 */
	private void reheap(Node<E> node, Stack<Node<E>> tempStack) {
        if(tempStack.isEmpty()) {
        	this.root = node;
        } else if(tempStack.peek().priority > node.priority) {
			return;
		} else {
			if (tempStack.peek().right == node) {
				Node<E> tempNode = tempStack.pop();
				tempNode.rotateLeft();
				if (!tempStack.isEmpty()) {
					if (tempStack.peek().right == tempNode) {
						tempStack.peek().right = node;
					}
					else {
						tempStack.peek().left = node;
					}
				}
			}
			else {
				Node<E> tempNode2 = tempStack.pop();
				tempNode2.rotateRight();
				if (!tempStack.isEmpty()) {
					if (tempStack.peek().right == tempNode2) {
						tempStack.peek().right = node;
					}
					else {
						tempStack.peek().left = node;
					}
				}
			}
			reheap(node, tempStack);
		}
	}

	/**
	 * Deletes a Node from the Treap by value
	 * @param key value to be deleted
	 * @return boolean on success of operation
	 */
    public boolean delete(E key) {
		if (find(key)) {
			this.root = delete(this.root, key);
	    	return true;
		} else {
			return false;
		}
    }

    /**
     * Recursive helper function for delete
     * @param tempNode
     * @param tempKey
     * @return
     */
    private Node<E> delete(Node<E> tempNode, E tempKey) {
    	if (tempNode != null) {
            if (tempKey.compareTo(tempNode.data) < 0) {
                tempNode.left = delete(tempNode.left, tempKey);
            } else if (tempKey.compareTo(tempNode.data) > 0) {
                tempNode.right = delete(tempNode.right, tempKey);
            } else {
                if (tempNode.left == null) {
                    return tempNode.right;
                } else if (tempNode.right == null) {
                    return tempNode.left;
                } else {
                    Node<E> tempNode2 = tempNode.right;
                    while(tempNode2.left != null) {
                    	tempNode2 = tempNode2.left;
                    }
                	tempNode.data = tempNode2.data;
                    tempNode.right = delete(tempNode.right, tempNode.data);
                }
            }
        }
        return tempNode;
    }

    /**
     * Determines if value exists within treap by value key and returns boolean
     * @param key the value being searched for
     * @return boolean on the success of the operation
     */
	public boolean find(E key) {
		return find(this.root, key);
	}

	/**
	 * Recursive helper function for find
	 * @param root
	 * @param key
	 * @return boolean on the success of the operation
	 */
    private boolean find(Node<E> root, E key) {
		if(root != null) {
			if(root.data.compareTo(key) == 0) {
				return true;
			}
			if(root.data.compareTo(key) < 0) {
				return find(root.right, key);
			}
			return find(root.left, key);
		} else {
			return false;
		}
    }

    /**
     * turns Treap into a string, no inputs needed because it is a method of the object
     * @return Returns the string representation of the Treap
     */
	public String toString() {
		return toString(root, 0);
	}

	/**
	 * Recursive helper function for toString
	 * @param node
	 * @param level
	 * @return string representation of the Treap
	 */
	private String toString(Node<E> node, int level) {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < level; i++) {
			result.append("  ");
		}
		if (node != null) {
			result.append(node.toString()+"\n" + toString(node.left, level + 1) +"\n" + toString(node.right, level + 1));
		} else {
			result.append("null");
		}
		return result.toString();
	}

	public static void main(String[] args) {
		// Constructed tests for basic functions and the example Treap
		boolean validity = true;
		Treap<Integer> tree = new Treap<Integer>();
		if (!tree.add(10, 10) && tree.add(10, 10) && !tree.find(10)) {
			validity = false;
		}
		if (tree.find(5) && !tree.delete(10) && tree.delete(10)) {
			validity = false;
		}
		Treap<Integer> tree1 = new Treap<Integer>();
		tree1.add(4 ,19);
		tree1.add(2 ,31);
		tree1.add(6 ,70);
		tree1.add(1 ,84);
		tree1.add(3 ,12);
		tree1.add(5 ,83);
		tree1.add(7 ,26);
		if (!"(key=1, priority=84)\n  null\n  (key=5, priority=83)\n    (key=2, priority=31)\n      null\n      (key=4, priority=19)\n        (key=3, priority=12)\n          null\n          null\n        null\n    (key=6, priority=70)\n      null\n      (key=7, priority=26)\n        null\n        null".equals(tree1.toString())) {
			validity = false;
		}
		tree1.delete(32);
		tree1.delete(7);
		tree1.delete(1);
		if(!"(key=5, priority=83)\n  (key=2, priority=31)\n    null\n    (key=4, priority=19)\n      (key=3, priority=12)\n        null\n        null\n      null\n  (key=6, priority=70)\n    null\n    null".equals(tree1.toString())) {
			validity = false;
		}
		if (validity) {
			System.out.println("All tests passed");
		} else {
			System.out.println("Tests failed");
		}
	}

}
